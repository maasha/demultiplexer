#!/usr/bin/env ruby

require 'optparse'
require 'demultiplexer'

# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< #
#                                                                              #
# Copyright (C) 2014-2015 Martin Asser Hansen (mail@maasha.dk).                #
#                                                                              #
# This program is free software; you can redistribute it and/or                #
# modify it under the terms of the GNU General Public License                  #
# as published by the Free Software Foundation; either version 2               #
# of the License, or (at your option) any later version.                       #
#                                                                              #
# This program is distributed in the hope that it will be useful,              #
# but WITHOUT ANY WARRANTY; without even the implied warranty of               #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                #
# GNU General Public License for more details.                                 #
#                                                                              #
# You should have received a copy of the GNU General Public License            #
# along with this program; if not, write to the Free Software                  #
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,    #
# USA.                                                                         #
#                                                                              #
# http://www.gnu.org/copyleft/gpl.html                                         #
#                                                                              #
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< #

USAGE = <<USAGE.gsub(/^\s+\|/, '')
  |This program demultiplexes Illumina Paired data given a samples file and four
  |FASTQ files containing forward and reverse index data and forward and reverse
  |read data.

  |The samples file consists of three tab-separated columns: sample_id, forward
  |index, reverse index).

  |The FASTQ files are generated by the Illumina MiSeq instrument by adding the
  |following key:

  |  <add key="CreateFastqForIndexReads" value="1">

  |To the `MiSeq Reporter.exe.config` file located in the `MiSeq Reporter`
  |installation folder, `C:\\Illumina\\MiSeqReporter` and restarting the `MiSeq
  |Reporter` service. See the MiSeq Reporter User Guide page 29:

  |http://support.illumina.com/downloads/miseq_reporter_user_guide_15042295.html

  |Thus Basecalling using a SampleSheet.csv containing a single entry `Data`
  |with no index information will generate the following files:

  |  Data_S1_L001_I1_001.fastq.gz
  |  Data_S1_L001_I2_001.fastq.gz
  |  Data_S1_L001_R1_001.fastq.gz
  |  Data_S1_L001_R2_001.fastq.gz
  |  Undetermined_S0_L001_I1_001.fastq.gz
  |  Undetermined_S0_L001_I2_001.fastq.gz
  |  Undetermined_S0_L001_R1_001.fastq.gz
  |  Undetermined_S0_L001_R2_001.fastq.gz
  |
  |Demultiplexing will generate file pairs according to the sample information
  |in the samples file and input file suffix, one pair per sample, and these
  |will be output to the output directory. Also a file pair with undetermined
  |reads are created where the index sequence is appended to the sequence name.
  |
  |It is possible to allow up to three mismatches per index. Also, read pairs
  |are filtered if either of the indexes have a mean quality score below a given
  |threshold or any single position in the index have a quality score below a
  |given theshold.
  |
  |Finally, a log file `Demultiplex.log` is output containing the status of the
  |demultiplexing process along with a list of the samples ids and unique index1
  |and index2 sequences.
  |
  |Usage: #{File.basename(__FILE__)} [options] <FASTQ files>
  |
  |Example: #{File.basename(__FILE__)} -m samples.tsv Data*.fastq.gz
  |
  |Options:
USAGE

DEFAULT_SCORE_MIN  = 16
DEFAULT_SCORE_MEAN = 16
DEFAULT_MISMATCHES = 1

ARGV << '-h' if ARGV.empty?

options = {}

OptionParser.new do |opts|
  opts.banner = USAGE

  opts.on('-h', '--help', 'Display this screen') do
    $stderr.puts opts
    exit
  end

  opts.on('-s', '--samples_file <file>', String, 'Path to samples file') do |o|
    options[:samples_file] = o
  end

  opts.on('-m', '--mismatches_max <uint>', Integer, 'Maximum mismatches_max ',
          "allowed (default=#{DEFAULT_MISMATCHES})") do |o|
    options[:mismatches_max] = o
  end

  opts.on('--revcomp_index1', 'Reverse complement index1') do |o|
    options[:revcomp_index1] = o
  end

  opts.on('--revcomp_index2', 'Reverse complement index2') do |o|
    options[:revcomp_index2] = o
  end

  opts.on('--scores_min <uint>', Integer, 'Drop reads if a single position in ',
          'the index have a quality score ',
          'below scores_min (default= ' \
          "#{DEFAULT_SCORE_MIN})") do |o|
    options[:scores_min] = o
  end

  opts.on('--scores_mean <uint>', Integer, 'Drop reads if the mean index',
          'quality score is below ',
          'scores_mean (default= ' \
          "#{DEFAULT_SCORE_MEAN})") do |o|
    options[:scores_mean] = o
  end

  opts.on('-o', '--output_dir <dir>', String, 'Output directory') do |o|
    options[:output_dir] = o
  end

  opts.on('-c', '--compress <gzip|bzip2>', String, 'Compress output using ' \
          'gzip or bzip2 ',
          '(default=' \
          '<no compression>)') do |o|
    options[:compress] = o.to_sym
  end

  opts.on('-v', '--verbose', 'Verbose output') do |o|
    options[:verbose] = o
  end
end.parse!

options[:mismatches_max] ||= DEFAULT_MISMATCHES
options[:scores_min]     ||= DEFAULT_SCORE_MIN
options[:scores_mean]    ||= DEFAULT_SCORE_MEAN
options[:output_dir]     ||= Dir.pwd

Dir.mkdir options[:output_dir] unless File.directory? options[:output_dir]

unless options[:samples_file]
  fail OptionParser::MissingArgument, 'No samples_file specified.'
end

unless File.file? options[:samples_file]
  fail OptionParser::InvalidArgument, "No such file: #{options[:samples_file]}"
end

unless options[:mismatches_max] >= 0
  fail OptionParser::InvalidArgument,
       "mismatches_max must be >= 0 - not #{options[:mismatches_max]}"
end

unless options[:mismatches_max] <= 3
  fail OptionParser::InvalidArgument,
       "mismatches_max must be <= 3 - not #{options[:mismatches_max]}"
end

unless options[:scores_min] >= 0
  fail OptionParser::InvalidArgument,
       "scores_min must be >= 0 - not #{options[:scores_min]}"
end

unless options[:scores_min] <= 40
  fail OptionParser::InvalidArgument,
       "scores_min must be <= 40 - not #{options[:scores_min]}"
end

unless options[:scores_mean] >= 0
  fail OptionParser::InvalidArgument,
       "scores_mean must be >= 0 - not #{options[:scores_mean]}"
end

unless options[:scores_mean] <= 40
  fail OptionParser::InvalidArgument,
       "scores_mean must be <= 40 - not #{options[:scores_mean]}"
end

if options[:compress]
  unless options[:compress] =~ /^gzip|bzip2$/
    fail OptionParser::InvalidArgument,
         "Bad argument to --compress: #{options[:compress]}"
  end
end

fastq_files = ARGV.dup

if fastq_files.size != 4
  fail ArgumentError, "Expected 4 input files - not #{fastq_files.size}"
end

Demultiplexer.run(fastq_files, options)
